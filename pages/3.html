<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep dive</title>
    <link rel="stylesheet" href="../static/styles.css">
    <style>
        dl {
            margin-block-start: 40px;
        }
        dl.main dt {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.95em;
            font-weight: 600;
        }
        dl.main dd {
            margin-block-end: 20px;
        }
        img.iterator-methods {
            display: block;
            width: 70%;
            margin: 0 auto;
        }
        @media(min-width: 600px) {
            img.iterator-methods {
                width: 45%;
            }
            dl.main dd {
                margin-block-end: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="main-title">
        <h1>String Docs</h1>
    </div>
    <div class="main-content">
        <h1 id="extracting-substrings">3. Deep dive</h1>
        <h2>3.1 Extracting substrings</h2>
        <p>
            Substrings need to be extracted from strings for various purposes
            such as isolating some information such as getting only the day or
            the month from the complete date, or for the purpose of removing
            <span id="slicing">unnecessary</span> parts of a string such as whitespaces of some special
            characters, or just taking a fixed amount of characters from the
            string as per some restrictions imposed and so on. The string
            class contains various methods to help with the same. Let us start
            by taking a look at the rather intuitive
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>.
            method.
        </p>
        <h3>3.1.1 Slicing</h3>
        <p>
            Slicing refers to the process of taking out a substring from a string
            using indices to indicate the beginning and ending positions of the
            substring which is to be extracted from the string.
            The string is not modified in the process and the method returns a new
            string object containing the slice. The basic syntax
            of slicing is <span class="mono">string.slice(start, end)</span>
            implemented as follows:
        </p>
        <div class="code-block">string text{"0123456789"};
std::cout &lt;&lt; text.slice(1, 4) &lt;&lt; '\n';</div>
        <p>Generates the following output:</p>
        <div class="code-block output">123</div>
        <p>
            Here, 1 specifies the starting position of the substring and 4 indicates
            the index of the position right after the last element of the substring.
            The <span class="mono">end</span> index is not included in the slice.
            The 
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method has two overloads which gives us the option of choosing whether
            or not to use the <span class="mono">start</span> index. If we just
            specify one value then the start is automatically assumed to be 0 which
            means the
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            operator gives us <span class="mono"><em>end</em></span> number of characters From
            the beginning of the string.
        </p>
        <div class="code-block">#include "arr_string.h"

int main()
{
    <comment>// If it is known that the first two
    // characters of the code specify the country
    // the we can take a slice containing the first
    // two characters from the string and we can find
    // out the country specified</comment>
    string code{"IN55FORBA48712"};
    std::cout &lt;&lt; "The country code is: " &lt;&lt; code.slice(2);
    
    return 0;
}</div>
        <p>Gives the following output:</p>
        <div id="paranths-operator" class="code-block output">The country code is: IN</div>
        <h3>3.1.2 Using the <span class="mono">()</span> operator</h3>
        <p>
            The 
            <a href="ref.html#paranths-operator" target="_blank"><span class="mono">()operator</span></a>
            can be used instead of using the slice method just for the sake of
            convenience. The 
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method and the 
            <a href="ref.html#paranths-operator" target="_blank"><span class="mono">()operator</span></a>
            can be used interchangeably. They work in the exact same way. The above examples
            using the 
            <a href="ref.html#paranths-operator" target="_blank"><span class="mono">()operator</span></a>:
        </p>
        <div class="code-block">string text{"0123456789"};
std::cout &lt;&lt; text(1, 4) &lt;&lt; '\n';</div>
        <p>Generates the following output:</p>
        <div class="code-block output">123</div>
        <p>
            The <a href="ref.html#paranths-operator" target="_blank"><span class="mono">()operator</span></a>
            generally seems more intuitive and easy to use but the
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method has a descriptive name which can be useful for new users.
        </p>
<div class="code-block">#include "arr_string.h"

int main()
{
    <comment>// If it is known that the first two
    // characters of the code specify the country
    // the we can take a slice containing the first
    // two characters from the string and we can find
    // out the country specified</comment>
    string code{"IN55FORBA48712"};
    std::cout &lt;&lt; "The country code is: " &lt;&lt; code(2);
    
    return 0;
}</div>
        <p>Gives the following output:</p>
        <div class="code-block output">The country code is: IN</div>
        <p id="fw-word">
            When using with only the <span class="mono"><em>end</em></span> index
            the <a href="ref.html#paranths-operator" target="_blank"><span class="mono">()operator</span></a>
            notation may seem a bit confusing as it appears that a function
            is being called.
        </p>
        <h3>3.1.3 First word/Last word</h3>
        <p>
            Sometimes there is a need to extract only the first or the last
            word from the string such as in case of extracting first and last
            names from the full name of a person. For such purposes the string
            class contains two methods: 
            <a href="ref.html#first-word" target="_blank"><span class="mono">first_word()</span></a>
            which extracts the first word from a string and returns a new
            string object containing that word
            and 
            <a href="ref.html#last-word" target="_blank"><span class="mono">last_word()</span></a>
            which extracts the last word from a string and returns a new
            string object containing that word. Both these methods ignore
            initial whitespaces in the string.
        </p>
<div class="code-block">#include "arr_string.h"

int main(void)
{
    string name{"    Gangaputra Bheeshma "};
    
    string first_name = name.first_word();
    string last_name = name.last_word();
    
    std::cout &lt;&lt; "First name: " &lt;&lt; first_name &lt;&lt; '\n';
    std::cout &lt;&lt; "Last name: " &lt;&lt; last_name &lt;&lt; '\n';

    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">First name: Gangaputra
Last name: Bheeshma</div>
        <p id="from-pos">
            As depicted above, the leading and trailing whitespaces
            are ignored by both these methods.
        </p>
        <h3>3.1.4 Extracting from a position</h3>
        <p>
            There may be a need to extract all the characters from a
            string starting from a specified position. If we do this using
            the 
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method then we will have to use the following syntax:
        </p>
        <div class="code-block">string text{"email: gesundheit@gmail.com"};
string email = text.slice(6, text.size());</div>
        <p>
            It can get quite cumbersome in complicated expressions. Keeping that
            in mind, the string class has a method
            <a href="ref.html#from-pos" target="_blank"><span class="mono">from_pos()</span></a>
            which returns a string containing all the characters starting from
            the specified index all the way up to the end. So the above can
            be written using 
            <a href="ref.html#from-pos" target="_blank"><span class="mono">from_pos()</span></a>
            as follows:
        </p>
        <div class="code-block">string text{"email: gesundheit@gmail.com"};
string email = text.from_pos(6);</div>
        <p id="nlast">
            The syntax is now cleaner and the name of the method 
            <a href="ref.html#from-pos" target="_blank"><span class="mono">from_pos()</span></a>
            gives a self description as to what it does. This method creates and
            returns a new string containing characters starting from the specified
            position all the way up to the end. This method does not modify
            the string.
        </p>
        <h3>3.1.5 Getting n last characters</h3>
        <p>
            You must have encountered several situations where a either a
            username or the password is made up from your own information
            for example, the password to open you electronic payslip File
            may be constructed by taking the first four letters of your name
            then appending your employee id followed by the last 5 digits of
            your phone number. This situation demands slicing of strings from
            the from and from the back as well. While we can use the
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method, the syntax might get a bit messy. The string class contains
            a method, 
            <a href="ref.html#nlast" target="_blank"><span class="mono">nlast()</span></a>
            for extracting a specified number of characters from
            the end of a string.
        </p>
        <p>Let us consider the example mentioned earlier:</p>
<div class="code-block">#include "arr_string.h"

int main(void)
{
    string name{"Amrendra Baahubali"};
    string employee_id{"5033FXAY19"};
    string phone{"7464878456"};
    
    string pass = (name.slice(4).get_upper() + employee_id + phone.nlast(5));
    std::cout &lt;&lt; "The password is: " &lt;&lt; pass;
    
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">The password is: AMRE5033FXAY1978456</div>
        <p>
            If we use the 
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method instead we will have to write the following:
        </p>
        <div class="code-block">string pass = (name.slice(4).get_upper() + employee_id + phone.slice(phone.size() - 5, phone.size()));</div>
        <p id="split" >
            Clearly the previous approach using the 
            <a href="ref.html#nlast" target="_blank"><span class="mono">nlast()</span></a>
            is the winner here. The syntax is very concise and the name is rather
            descriptive which makes it more intuitive to use, plus the calculations
            which need to be performed for using the 
            <a href="ref.html#slice" target="_blank"><span class="mono">slice()</span></a>
            method can be confusing.
        </p>
        <h3>3.1.6 Split</h3>
        <p>
            Sometimes extracting the characters from the string may not enough
            and the problem may require breaking up the string into its
            constituents. Consider the Email ID example again. Every person has
            a different username and domain name and each of them are of different
            lengths. Up to this point, all our methods for extracting substrings
            from strings depend upon the length which is unknown in this case
            so any of the above methods cannot be applied directly.
            The 
            <a href="ref.html#split" target="_blank"><span class="mono">split()</span></a> method
            however can come in handy here. The 
            <a href="ref.html#split" target="_blank"><span class="mono">split()</span></a> method
            splits the string at the character specified as an argument to the method
            and it returns a list of strings which consists of the individual
            parts of the string obtained after splitting. The original string however
            is not modifed. The data is copied into the substrings.
        </p>
        <p>
            For the above mentioned problem we can use the 
            <a href="ref.html#nlast" target="_blank"><span class="mono">nlast()</span></a>
            method as follows:
        </p>
<div class="code-block">#include "arr_string.h"

int main(void)
{
    string email{"claustrophobe@elevator.trpd"};

    auto comp = email.split('@');
    
    std::cout &lt;&lt; "List of substrings: " &lt;&lt; comp &lt;&lt; '\n';
    std::cout &lt;&lt; "Username: " &lt;&lt; comp[0] &lt;&lt; '\n';
    std::cout &lt;&lt; "Domain: " &lt;&lt; comp[1] &lt;&lt; '\n';

    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">List of substrings: ["claustrophobe", "elevator.trpd"]
Username: claustrophobe
Domain: elevator.trpd</div>
        <p id="iter-and-mod">
            Using <a href="ref.html#split" target="_blank"><span class="mono">split()</span></a>
            we didn't have to worry about the length of the strings or substrings.
            It can also prove useful in many other situations where constituents are
            more important than the whole.
        </p>
        <h2 id="iterators">3.2 Iteration and modification</h2>
        <h3>3.2.1 Iterators</h3>
        <p>
            Let us first define what an iterator is. An <strong>Iterator</strong>
            is a pointer like object which points to an element inside a container.
            It provides access to the element it is pointing towards and it can be
            made to point to the next element in the container using the increment
            <span class="mono">(++)</span> operator. Using the iterator all the
            elements of a container can be accessed and modified (if it's not a 
            <em>const</em> iterator). The element which the iterator is pointing
            towards is accessed using the <span class="mono">'*'</span> operator
            and two iterators can be compared using the <span class="mono">'=='</span>
            and <span class="mono">'!='</span> operators.
        </p>
        <p>
            Do they sound exactly like pointers? Yes they do and pointers are powerful
            iterators for array types but for complicated data structures more
            sophisticated iterators are required. However that is not our concern
            at the moment.
        </p>
        <p>
            Objects of the string class can be thought of as containers which contain
            individual characters. The string class has methods which return iterators
            which can be used to iterate through a string.
            The different types of iterators defined for the string class are as follows:
            <table class="solid">
                <thead>
                    <tr>
                        <th>Iterator type</th>
                        <th>Method which returns this iterator</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-iterator">string::iterator</a>
                        </td>
                        <td>
                            string::iterator begin()
                        </td>
                    </tr>
                    <tr>
                        <td>
                            string::iterator end()
                        </td>
                    </tr>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-const-iterator">string::const_iterator</a>
                        </td>
                        <td>
                            string::const_iterator begin() [for <em>const</em> objects]
                        </td>
                    </tr>
                    <tr>
                        <td>
                            string::const_iterator end() [for <em>const</em> objects]
                        </td>
                    </tr>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-const-iterator">string::const_iterator</a>
                        </td>
                        <td>string::const_iterator cbegin()</td>
                    </tr>
                    <tr><td>string::const_iterator cend()</td></tr>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-reverse-iterator">string::reverse_iterator</a>
                        </td>
                        <td>std::reverse_iterator rbegin()</td>
                    </tr>
                    <tr><td>std::reverse_iterator rend()</td></tr>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-const-reverse-iterator">string::const_reverse_iterator</a>
                        </td>
                        <td>string::const_reverse_iterator rbegin() [for <em>const</em> objects]</td>
                    </tr>
                    <tr><td>string::const_reverse_iterator end() [for <em>const</em> objects]</td></tr>
                    <tr>
                        <td rowspan="2">
                            <a href="ref.html#string-const-reverse-iterator">string::const_reverse_iterator</a>
                        </td>
                        <td>string::const_reverse_iterator crbegin()</td>
                    </tr>
                    <tr><td>string::const_reverse_iterator crend()</td></tr>
                </tbody>
            </table>
        </p>
        <dl class="main">
            <dt><a href="ref.html#string-iterator">string::iterator</a></dt>
            <dd>
                It is the basic read/write iterator which can be used to traverse
                the string as well as write data into it.
            </dd>
            <dt><a href="ref.html#string-const-iterator">string::const_iterator</a></dt>
            <dd>
                It is a <em>read only</em> iterator which allows traversal through the
                string but no modifications are allowed.
            </dd>
            <dt><a href="ref.html#string-reverse-iterator">string::reverse_iterator</a></dt>
            <dd>
                It is a reverse iterator which means that as we keep incrementing it,
                it moves backwards through the string. This is a read/write iterator
                which can be used to read the contents of the string in reverse order
                and also write something to it. More on it in section
                <a href="#reverse-iterators">3.2.3</a>
            </dd>
            <dt><a href="ref.html#string-const-reverse-iterator">string::const_reverse_iterator</a></dt>
            <dd>
                It is a <em>read only</em> iterator which allows traversal through the
                string in the reverse order but no modification is allowed.
            </dd>
        </dl>
        <p>
            You might have noticed that the methods which return iterators come in pairs.
            For the <a href="ref.html#string-iterator"><span class="mono">string::iterator</span></a> we have
            <a href="ref.html#begin" target="_blank"><span class="mono">begin()</span></a>
            and 
            <a href="ref.html#end" target="_blank"><span class="mono">end()</span></a>.
            The
            <a href="ref.html#begin" target="_blank"><span class="mono">begin()</span></a>
            method returns
            a <a href="ref.html#string-iterator" target="_blank"><span class="mono">string::iterator</span></a>
            to the beginning of the string and the
            <a href="ref.html#end" target="_blank"><span class="mono">end()</span></a> method returns
            a <a href="ref.html#string-iterator" target="_blank"><span class="mono">string::iterator</span></a>
            to <em>one character past</em> the last character
            of the string.
        </p>
        <img class="iterator-methods" src="../static/iterator.png" alt="Working of begin and end methods">
        <p>
            The 
            <a href="ref.html#cbegin" target="_blank"><span class="mono">cbegin()</span></a> and 
            <a href="ref.html#cend" target="_blank"><span class="mono">cend()</span></a> methods
            return
            <a href="ref.html#string-const-iterator" target="_blank"><span class="mono">string::const_iterator</span></a>
            to the beginning and end in the same way as described above. The only difference is that the 
            <a href="ref.html#string-const-iterator" target="_blank"><span class="mono">string::const_iterator</span></a>
            is a <em>read only</em> iterator which means we can access the elements of the string
            using them but we cannot modify any element.
        </p>
        <p>
            Now that we have covered some of the basics of iterators, let us take a
            look at how to use them to iterate through the string:
        </p>
        <div class="code-block">#include "arr_string.h"

int main(void)
{
    string str{"This is a string"};

    <comment>// Getting the iterators using the
    // begin() and end() methods</comment>

    string::iterator iter = str.begin();
    string::iterator end = str.end();

    <comment>// Iterating through the string</comment>
    for (; iter != end; ++iter)
        std::cout &lt;&lt; *iter &lt;&lt; ' ';
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div id="const-iterators" class="code-block output">T h i s   i s   a   s t r i n g</div>
        <h3>3.2.2 const iterators</h3>
        <p>
            A <em>const</em> iterator is simply an iterator which is <em>read only</em>.
            It can be used to traverse through the elements of a container object (which
            is the 'string' object in our context) but not modify them. They come in
            handy when the objective is to only read the contents of the string and
            not modify it. The 
            <a id="reverse-iterators" href="ref.html#cbegin" target="_blank"><span class="mono">cbegin()</span></a>
            and
            <a href="ref.html#cend" target="_blank"><span class="mono">cend()</span></a>
            methods return the <em>const</em> iterators of the string class, the
            <a href="ref.html#string-const-iterator" target="_blank"><span class="mono">string::const_iterator</span></a>.
            Also keep in mind that the 
            <a href="ref.html#const-begin" target="_blank"><span class="mono">begin()</span></a>
            and
            <a href="ref.html#const-end" target="_blank"><span class="mono">end()</span></a>
            methods will also return a 
            <a href="ref.html#string-const-iterator" target="_blank"><span class="mono">string::const_iterator</span></a>
            when used with a <em>const</em> string object.
        </p>
        <h3>3.2.3 Reverse iterators</h3>
        <p>
            A reverse iterator is used to traverse through the elements of a container
            in the reverse order i.e., from the last element to the first. The 
            <a href="ref.html#rbegin" target="_blank"><span class="mono">rbegin()</span></a>
            and 
            <a href="ref.html#rend" target="_blank"><span class="mono">rend()</span></a> methods
            return the reverse iterators for the string class, the 
            <a href="ref.html#string-reverse-iterator" target="_blank"><span class="mono">string::reverse_iterator</span></a>.
            The
            <a href="ref.html#rbegin" target="_blank"><span class="mono">rbegin()</span></a> method
            returns a
            <a href="ref.html#string-reverse-iterator" target="_blank"><span class="mono">string::reverse_iterator</span></a>
            to the last character of the string and the 
            <a href="ref.html#rend" target="_blank"><span class="mono">rend()</span></a> method
            returns a
            <a href="ref.html#string-reverse-iterator" target="_blank"><span class="mono">string::reverse_iterator</span></a>
            to one character before the first character of the string.
        </p>
        <img class="iterator-methods" src="../static/reverse-iterator.png" alt="Working of rbegin and rend methods">
        <p>
            The 
            <a href="ref.html#crbegin" target="_blank"><span class="mono">crbegin()</span></a> and
            <a href="ref.html#crend" target="_blank"><span class="mono">crend()</span></a> methods
            work the same as above with the only difference that instead of the 
            <a href="ref.html#string-reverse-iterator" target="_blank"><span class="mono">string::reverse_iterator</span></a>
            they return 
            <a href="ref.html#string-const-reverse-iterator" target="_blank"><span class="mono">string::const_reverse_iterator</span></a>
            which is a <em>read only</em> iterator and can only be used to read from the string not
            write to it.
        </p>
        <p>
            Let us now look at a reverse iterator in action:
        </p>
<div class="code-block">#include "arr_string.h"

int main(void)
{
    string str{"This is a string"};

    <comment>// Getting the reverse iterators using
    // the rbegin() and rend() methods</comment>

    string::reverse_iterator riter = str.rbegin();
    string::reverse_iterator rend = str.rend();
    
    for (; riter != rend; ++riter)
        std::cout &lt;&lt; *riter &lt;&lt; ' ';
    
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">g n i r t s   a   s i   s i h T</div>
        <p id="const-reverse-iterators">
            Traversing the string through the reverse iterator is like traversing
            the reversed string.
        </p>
        <h3>3.2.4 const reverse iterators</h3>
        <p>
            A <em>const</em> reverse iterator
            is simply a reverse iterator which is <em>read only</em>.
            It can be used to traverse through the elements of a container object in the
            reverse order (which is the 'string' object in our context) but not modify them.
            They come in handy when the objective is to only read the contents of the
            string in reverse order and not modify it. The
            <a href="ref.html#crbegin" target="_blank"><span class="mono">crbegin()</span></a>
            and     
            <a href="ref.html#crend" target="_blank"><span class="mono">crend()</span></a>
            methods return the <em>const</em> reverse iterators of the string class, the
            <a href="ref.html#string-const-reverse-iterator" target="_blank"><span class="mono">string::const_reverse_iterator</span></a>.
            Also keep in mind that the 
            <a href="ref.html#rbegin" target="_blank"><span class="mono">rbegin()</span></a>
            and 
            <a href="ref.html#rend" target="_blank"><span class="mono">rend()</span></a>
            methods will also return a 
            <a href="ref.html#string-const-reverse-iterator" target="_blank"><span class="mono">string::const_reverse_iterator</span></a>
            when used with a <em>const</em> string object.
        </p>
        <p>
            Let us take a look at an example program to illustrate the use of iterators
            to get a reversed string from an existing string.
        </p>
        <div class="code-block">#include "arr_string.h"

string get_reverse(const string& str){
    string rev{str};
    
    <span class="comment">// Getting the const reverse iterator of str</span>
    auto str_iter = str.crbegin();

    <span class="comment">// Getting the iterator of rev</span>
    auto rev_iter = rev.begin();
	
    <span class="comment">// Assigning the character pointed to by the
    // reverse iterator to the character pointed to by the iterator</span>
    for (; str_iter != str.crend(); ++str_iter, ++rev_iter)
        *rev_iter = *str_iter;
    
    return rev;
}

int main(void)
{
    string str{"This is a string"};
    string reversed{get_reverse(str)};
    
    std::cout &lt;&lt; reversed;
    
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">gnirts aa string</div>
        <p>
            In the program above a copy of the string is first created then
            a reverse iterator to the string <span class="mono">str</span> is
            initialized (<span class="mono">str_iter</span>) and an iterator
            to the copy string <span class="mono">rev</span> is initialized
            (<span class="mono">rev_iter</span>).
            Moving through the string using a reverse iterator is just
            like moving through the reversed string. We use this fact to move
            through the <em id="modify-method">pseudo</em> reversed string using the reverse iterator and
            assign each character of the <em>pseudo</em> reverse string to the
            characters of <span class="mono">rev</span> while moving forwards
            through <span class="mono">rev</span>.
        </p>
        <h3>3.2.5 The modify method</h3>
        <p>
            The 
            <a href="ref.html#modify" target="_blank"><span class="mono">modify()</span></a>
            method of the string class allows us to modify a string character by
            character using a <em>function like object</em> which is passed as an
            argument to this method. A <em>function</em> like entity in <span class="mono">C++</span>
            can be a plain-old function, or a functor (function object), or a lambda expression.
            If it is a function then a pointer to the function has to be passed to the
            <a href="ref.html#modify" target="_blank"><span class="mono">modify()</span></a>
            method. Let us see some examples:
        </p>
<div class="code-block">#include "arr_string.h"

char shift_right(char ch){
    return ch + 3;
}

char shift_left(char ch){
    return ch - 3;
}

int main(void)
{
    string str{"abcde"};

    std::cout &lt;&lt; "Initial value: " &lt;&lt; str &lt;&lt; '\n';

    str.modify(shift_right);
    std::cout &lt;&lt; "\nShifting right: " &lt;&lt; str &lt;&lt; '\n';

    str.modify(shift_left);
    std::cout &lt;&lt; "\nShifting left: " &lt;&lt; str &lt;&lt; '\n';
    
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">Initial value: abcde 

Shifting right: defgh

Shifting left: abcde </div>
        <p>
            We use the <span class="mono">shift_right</span> function to shift
            each character of the string to the right by three places and then
            the <span class="mono">shift_left</span> function to shift each
            character of the string to the left by three places to get the original
            string back.
        </p>
        <p>
            We can also use predicates to specify which characters of the string are
            to be modified. This can be done by passing a function like entity
            to the the parameter <span class="mono"><em>pred</em></span> of 
            <a href="ref.html#modify" target="_blank"><span class="mono">modify()</span></a>
            method. The pre-requisite is that <span class="mono"><em>pred</em></span>
            must be able to accept a single <span class="mono"><em>char</em></span> as
            an argument and must return a boolean value. Let us take a look at an example
            where we replace all the lowercase characters of a string with underscores:
        </p>
<div class="code-block">#include "arr_string.h"
#include &lt;ctype.h&gt;

bool under(char&){ return '_' ; }

int main(void)
{
    string str{"This Is A Title Cased String"};

    std::cout &lt;&lt; "Before modification: " &lt;&lt; str &lt;&lt; '\n';

    str.modify(under, islower);

    std::cout &lt;&lt; "\nAfter modification: " &lt;&lt; str &lt;&lt; '\n';

    &lt;&lt;
    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">Before modification: This Is A Title Cased String

After modification: T___ I_ A T____ C____ S_____ </div>
        <p>
            The predicate we used is the C-standard library function 
            <a href="https://en.cppreference.com/w/c/string/byte/islower" target="_blank"><span class="mono">islower()</span></a>
            an it returns true for lowercase characters so only the lowercase characters
            are modified in the string using the modifier function which is a
            function which just returns an underscore (<span class="mono">'_'</span>) every
            time it is called. Using <span class="mono"><em>lambda expressions</em></span> can
            make the task even easier. Take a look at the below example:
        </p>
<div class="code-block">#include "arr_string.h"
#include &lt;ctype.h&gt;

int main(void)
{
    string str{"This Is A Title Cased String"};

    std::cout &lt;&lt; "Before modification: " &lt;&lt; str &lt;&lt; '\n';

    str.modify(
        [](char&){
            return '_';
        },
        islower
    )

    std::cout &lt;&lt; "\nAfter modification: " &lt;&lt; str &lt;&lt; '\n';

    return 0;
}</div>
        <p>Will generate the following output:</p>
        <div class="code-block output">Before modification: This Is A Title Cased String

After modification: T___ I_ A T____ C____ S_____ </div>
    </div>
</body>
</html>
